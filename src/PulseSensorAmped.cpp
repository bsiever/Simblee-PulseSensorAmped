/*
 * Developed by Bill Siever (http://siever.info)
 * 
 * Based on http://pulsesensor.com/
 *
 * v. 0.5
 */

/*
  PulseSensorAmped.h - Collect data from one (or more) Amped Pulse Sensors
  (http://pulsesensor.com/)
  Copyright (c) 2016 William Siever.  All right reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "PulseSensorAmped.h"


// Declare the instance
PulseSensorAmpedClass PulseSensorAmped;



/************ static functions common to all instances ***********************/
// Forward declaration of timer interrupt
void TIMER2_Interrupt(void);


// ********** Timer2 configuration functions *****

// Based on user forum details at: http://forum.rfduino.com/index.php?topic=155.msg4003#msg4003
static void timer(unsigned int ms)                                 // directly pass the value you want the cycle to be in mS
{
  NRF_TIMER2->TASKS_STOP = 1;                                      // Stop timer
  NRF_TIMER2->MODE = TIMER_MODE_MODE_Timer;                        // sets the timer to TIME mode (doesn't make sense but OK!)
  NRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit;               // with BLE only Timer 1 and Timer 2 and that too only in 16bit mode
  NRF_TIMER2->PRESCALER = 9;                                       // Prescaler 9 produces 31250 Hz timer frequency => t = 1/f =>  32 uS
                                                                   // The figure 31250 Hz is generated by the formula (16M) / (2^n) 
                                                                   // where n is the prescaler value 
                                                                   // hence (16M)/(2^9)=31250 
  NRF_TIMER2->TASKS_CLEAR = 1;                                     // Clear timer
  
  //-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  //        Conversion to make cycle calculation easy
  //        Since the cycle is 32 uS hence to generate cycles in mS we need 1000 uS 
  //        1000/32 = 31.25  Hence we need a multiplication factor of 31.25 to the required cycle time to achive it
  //        e.g to get a delay of 10 mS      we would do
  //        NRF_TIMER2->CC[0] = (10*31)+(10/4);
  //-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
  NRF_TIMER2->CC[0] = (ms * 31) + (ms / 4);                                                                                  //CC[0] register holds interval count value i.e your desired cycle
  NRF_TIMER2->INTENSET = TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos;                                     // Enable COMAPRE0 Interrupt
  NRF_TIMER2->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos);                             // Count then Complete mode enabled
  attachInterrupt(TIMER2_IRQn, TIMER2_Interrupt);                                                                            // also used in variant.cpp in the RFduino2.2 folder to configure the RTC1 
}

// Timer 2 interrupt triggers a pulse beat update
void TIMER2_Interrupt(void)
{
  if (NRF_TIMER2->EVENTS_COMPARE[0] != 0)
  {  
    // Timer Event 
    PulseSensorAmped.update();
    NRF_TIMER2->EVENTS_COMPARE[0] = 0;
  }
}


// Constructor
PulseSensorAmpedClass::PulseSensorAmpedClass() {
  analogPin = -1;
}

                                                                                                                                                                                                                                                                              
// Configure the sensor
void PulseSensorAmpedClass::attach(int pin) {
  // Do not allow analog pin to change
  if(analogPin==-1) {
    analogPin = pin;
  }
  timer(2); // Enable a 2ms timer.
}

void PulseSensorAmpedClass::start(void) {
  // Only allow the sensor to start/stop if the pin is configured
  // Start TIMER (If pin configured)
  if(analogPin != -1)
    NRF_TIMER2->TASKS_START = 1;                                                                                               

  // Re-initialize variables:
  sampleCounter = 0;
  lastBeatTime = 0; 
  peak = 512;
  trough = 512;
  thresh = 525;
  amplitude = 100;
  IBI = 600;
  pulse = false;
  pulseLost = true;
  beatCount = 0;
  postUpdate = false;
}

void PulseSensorAmpedClass::stop(void) {
  // Stop measurements
  NRF_TIMER2->TASKS_STOP = 1;                                      
  postUpdate = false;
}



void PulseSensorAmpedClass::update() {              // Update this ever 2ms
  static int rate[10];                         // array to average IBI values for average rate
  static int amplitudes[10];                   // array to average amplitude values for average rate
  static int beatCount = 0;

  int signal;  
  signal = analogRead(analogPin);              // read the Pulse Sensor 
  sampleCounter += 2;                          // keep track of the time in mS with this variable

  unsigned elapsedTime = sampleCounter - lastBeatTime;  // Time passed since the last beat
  boolean beyondDichrotic = elapsedTime > (IBI/5)*3;    // Has sufficient time passed to avoid the dichrotic noise?
 
  //  find the peak and trough of the pulse wave
  if(signal < thresh) {         // Update trough based on threshold
    if(beyondDichrotic) {       // avoid dichrotic noise when finding trough
      trough = min(signal, trough);
    } 
  } else {                      // Signal is > threshold;  Potentially update peak
    peak = max(signal, peak);  
  }                                        

  // Search for a beat
  if (elapsedTime > 250){                         // Assume at least 250ms between beats (i.e., BPM<240); Helps avoid noise

    // See if the signal indicates the beginning of a pulse phase
    if ( (signal > thresh) && (pulse == false) && beyondDichrotic){        
      // A pulse phase has started 
      pulse = true;

      IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS (Starting from point the threshold is exceeded)
      lastBeatTime = sampleCounter;               // keep track of the start time of this beat

      // Add the count to the buffer
      rate[beatCount%10] = IBI;
      amplitudes[beatCount%10] = amplitude;

      // Assuming this won't roll over (4Billion beats?)
      beatCount++;

      // If too few beats, discard them
      if(beatCount<3) {
        return;
      } else if(beatCount==3) {
        // First measurement is iffy. Average 2nd and 3rd
        rate[0]=(rate[1]+rate[2])/2;  
        amplitudes[0] = (amplitudes[1]+amplitudes[2])/2;
      }

      // Total the available beats
      word runningTotal = 0;
      word runningAmp = 0;
      int maxIndex = min(beatCount, 10);      
      for(int i=0; i<maxIndex; i++){                
        runningTotal += rate[i];              
        runningAmp += amplitudes[i];
      }
      runningTotal /= maxIndex;               // average the last 10 IBI values 
      runningAmp /= maxIndex;
      BPM = 60000/runningTotal;               // how many beats can fit into a minute? that's BPM!

      pulseLost = false;                      // Definitely have a valid pulse now
      // If minimum average and last amplitude appropriate, relay data
      if(runningAmp>50 && amplitude>50) {
        postUpdate = true;
      }
    }                       
  }

  if (signal < thresh && pulse == true){      // when the values are going down the beat is over
    amplitude = peak - trough;                // Compute the amplitude of the last sample
    pulse = false;                            // Update status
    thresh = amplitude/2 + trough;            // Use 50% of the last amplitude as new threshold
    peak = thresh;                            // Peak won't update until beyond threshold
    trough = thresh;                          // Trough won't update until beyond threshold
  }

  if(elapsedTime > 2500) {                 // if 2.5S elapse without a valid beat
    if(!pulseLost) {                       // If it was good, notify the loss
      BPM = -1;
      postUpdate = true;
    }
    // Reset state variables to default state
    thresh = 512;                          // set thresh default
    peak = 512;                            // set P default
    trough = 512;                          // set T default
    lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date        
    pulseLost = true;
    beatCount = 0;
  }
}

void PulseSensorAmpedClass::process(void) {
  // Put updates into foreground
  if(postUpdate) {
    if(BPM>=0)
      PulseSensorAmped_data(BPM, IBI);
    else
      PulseSensorAmped_lost();	         
    postUpdate = false;
  } 
}
